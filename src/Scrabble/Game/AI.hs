{-# LANGUAGE TupleSections #-}
{-|
Module      : Scrabble.Game.AI
Description : An AI scrabble player.
Maintainer  : j.burton@brighton.ac.uk
Stability   : experimental
Portability : POSIX

An AI Scrabble player. Don't be fooled by the term 'AI' -- it is currently as dumb as a rock :-)
It can pick a word from the dictionary that either begins with or ends with a given letter.
Choosing words that can be played onto the board in other ways and searching for the highest
scoring word is WIP.
-}
module Scrabble.Game.AI
  ( newGame1P
  , moveAI )
  where

--import Debug.Trace
import Prelude hiding ( Word )
import qualified Data.Map as Map
import Data.Maybe (catMaybes)
import Data.List (maximumBy)
import Data.Functor ((<&>))
import Data.Text (Text)
import System.Random (StdGen)
import Lens.Simple ((^.),(.~),(&))
import Scrabble.Types
  ( Evaluator(..)
  , Dict
  , Game(..)
  , Board
  , dict, playable, firstMove, turn, board
  , Player(..)
  , rack
  , FreedomDir(..)
  , Freedom
  , Rack
  , WordPut
  , Pos
  , Dir(..)
  , Word
  , Turn(..)
  , Letter(Blank)
  , MoveResult(..) )
import Scrabble.Board.Board
  ( makeWordPut
  , updateBoard
  , newBoard
  , additionalWords
  , scoreWords
  , wordPutToWord
  , empty) 
import Scrabble.Board.Bag
  ( newBag
  , fillRack )
import Scrabble.Lang.Word
  ( wordToText
  , wordPutToText )
import Scrabble.Game.Game ( pass )
import Scrabble.Game.Internal
  ( toggleTurn
  , getPlayer
  , updatePlayables
  , updatePlayer
  , setScore )
import Scrabble.Lang.Search
  ( findPrefixes
  , findSuffixes
  , wordsInDict )

-- * AI functions

-- | Start a new game against the computer.
newGame1P :: Text   -- ^ Name of Player
          -> StdGen -- ^ The random generator
          -> Dict   -- ^ The dictionary
          -> Game
newGame1P pName theGen d = 
  let Ev (Right (rack1, bag1, gen')) = fillRack [] newBag theGen
      p1 = Player { _name  = pName
                  , _rack  = rack1
                  , _score = 0
                  , _isAI  = False }
      Ev (Right (rack2, bag2, gen'')) = fillRack [] bag1 gen'
      p2 = Player { _name  = "Haskell"
                  , _rack  = rack2
                  , _score = 0
                  , _isAI  = True }
      g  = Game { _board     = newBoard
                , _bag       = bag2
                , _player1   = p1
                , _player2   = p2
                , _turn      = P1
                , _gen       = gen''
                , _firstMove = True
                , _dict      = d
                , _gameOver  = False
                , _playable  = Map.empty
                , _lastMovePass = False } in
    g

-- | Play a word onto a board as the AI player, Returns the new game and the score of this move.
--   Validation of the word is carried out when finding the word.
--   Sets the new board, updates the current player's score, refills their rack with letters, then
--   toggles the current turn.
--   Returns:
--     + the updated game,
--     + the word played,
--     + additional words generated by the move,
--     + the indices of any blanks played in the move, and
--     + the score.
--   TODO if the AI can't find a word, swap tiles instead of passing.
--   TODO handle blanks
moveAI :: Game      -- ^ The game.
       -> Evaluator (Game, MoveResult)
moveAI g = do
  let r  = g ^. (getPlayer g . rack)
      mw = findWord g (filter (/=Blank) r)  
  case mw of
    Nothing -> pass g >>= \g' -> pure (g', MoveResult (g ^. turn) [] [] [] 0)
    Just (w,aw)  -> scoreWords g w aw >>=
                    \i -> setScore (g & firstMove .~ False) i >>= updatePlayer w
                    >>= updatePlayables w >>= updateBoard w
                    >>= toggleTurn <&> (, MoveResult (g ^. turn) w (map wordPutToWord (w:aw)) [] i)

-- Pick a word for the AI to play, along with the additional words it generates. 
findWord :: Game     -- The game.
         -> Rack     -- The rack.
         -> Maybe (WordPut, [WordPut]) -- The word and the additional words.
findWord g r =
  let ws = Map.foldlWithKey (\acc k v -> case findWord' k v of
                                Nothing  -> acc
                                Just mws -> mws : acc) [] (g ^. playable) in
    maxWd ws
  where findWord' :: Pos -> (Letter,[Freedom]) -> Maybe (WordPut, [WordPut])
        findWord' k (l,fs) =
          let mwds = map (\(fd,i) ->
                             case fd of
                               UpD    -> findPrefixOfSize g k l r (fd,i) 
                               DownD  -> findSuffixOfSize g k l r (fd,i) 
                               LeftD  -> findPrefixOfSize g k l r (fd,i) 
                               RightD -> findSuffixOfSize g k l r (fd,i)) fs
              --wds = trace("findWord' at pos "<>show fs<>" starting with letter "<>show l) catMaybes mwds in
              wds = catMaybes mwds in
            maxWd wds
        maxWd :: [(WordPut, [WordPut])] -> Maybe (WordPut,[WordPut])
        maxWd wds = if null wds
                    then Nothing
                    else Just (maximumBy (\o1 o2 -> length (fst o1)
                                           `compare` length (fst o2)) wds)

-- Find a word of at least a certain size that ends with a certain letter.
findPrefixOfSize :: Game             -- The dictionary.
                 -> Pos              -- The end point of the word.
                 -> Letter           -- The letter on the board that this word will connect to.
                 -> Rack             -- The letters from the player's hand to make up the word
                 -> (FreedomDir,Int) -- The direction and max length of the word.
                 -> Maybe (WordPut, [WordPut]) -- The word and the additional words.
findPrefixOfSize g p l = findWordOfSize g (findPrefixes g l) p

-- Find a word of at least a certain size that begins with a certain letter.
findSuffixOfSize :: Game             -- The game.
                 -> Pos              -- The starting point of the word.
                 -> Letter           -- The letter on the board that this word will connect to.
                 -> Rack             -- The letters from the player's hand to make up the word
                 -> (FreedomDir,Int) -- The direction and max length of the word.
                 -> Maybe (WordPut,[WordPut]) -- The word and the additional words.
findSuffixOfSize g p l = findWordOfSize g (findSuffixes g l) p

-- Get the longest sublist in a list of lists. Not safe (list must have something in it).
longest :: [[a]] -> [a]
longest = maximumBy (\x y -> length x `compare` length y)

-- A function for finding words in the dictionary.
type WordFinder = Word -> [Word] 

-- Find a word of a certain size.
-- TODO max 6 letter words at the moment. Too slow for seven letter words...
findWordOfSize :: Game             -- The game.
               -> WordFinder       -- Function that will query the dictionary.
               -> Pos              -- The start or end point of the word.
               -> Rack             -- The letters from the player's hand to make up the word.
               -> (FreedomDir,Int) -- The direction and max length of the word.
               -> Maybe (WordPut,[WordPut]) -- The word and its additional words.
findWordOfSize g wf k r (fd,i) =
  let r' = filter (/=Blank) r
      ws = filter ((<=i) . length) $ wf r' in
    if null ws
    then Nothing
    else let w   = longest ws
             len = length w - 1
             dir = if fd == UpD || fd == DownD then VT else HZ
             -- where does this word begin?
             pos = case fd of
               UpD    -> (fst k-len,snd k)
               DownD  -> k
               LeftD  -> (fst k,snd k-len)
               RightD -> k
             wp = makeWordPut (wordToText w) pos dir [] in           
           case additionalWords g wp of
             Ev (Left _)   -> Nothing
             Ev (Right aw) -> if not $ freeButOne (g ^. board) wp
                                 && wordsInDict (g ^. dict) (map wordPutToText aw)
                              then Nothing
                              else Just (wp,aw)

-- Check that all positions but one are free in a Wordput.
-- This would need to be changed if we make the AI smart enough to select
-- words that reuse more than one tile at the very beginning or ending of the new word.
freeButOne :: Board -> WordPut -> Bool
freeButOne b wp = let bs = map (empty b . fst) wp in
  and (tail bs) || and (init bs)
